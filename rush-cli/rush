#!/usr/bin/env bash
# This script was generated by bashly 0.8.4 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
rush_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush - Personal package manager\n"
    echo

  else
    printf "rush - Personal package manager\n"
    echo

  fi

  printf "Usage:\n"
  printf "  rush [command]\n"
  printf "  rush [command] --help | -h\n"
  printf "  rush --version | -v\n"
  echo
  # :command.usage_commands
  printf "Repository Commands:\n"
  echo "  add           Register a local repository"
  echo "  remove        Unregister a local repository"
  echo
  printf "Git Commands:\n"
  echo "  clone         Clone a GitHub package repository"
  echo "  pull          Git pull one or all repositories"
  echo "  push          Git push one or all repositories"
  echo
  printf "Config Commands:\n"
  echo "  config        Show or edit the configuration file"
  echo "  default       Set a default repository"
  echo
  printf "Package Commands:\n"
  echo "  get           Install a package (default)"
  echo "  undo          Uninstall a package"
  echo "  snatch        Install a package from a remote repo"
  echo "  copy          Copy a package between local repositories"
  echo "  info          Show information about a package"
  echo "  list          Show packages in one or all repositories"
  echo "  search        Search in package names and info files"
  echo "  edit          Edit package files"
  echo "  show          Show package files"
  echo
  printf "Internal Commands:\n"
  echo "  completions   Generate bash completions"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"

    # :environment_variable.usage
    echo "  RUSH_CONFIG"
    printf "    Location of the rush config file.\n    Default: ~/rush.ini\n"
    echo

  fi
}

# :command.usage
rush_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush add\n"
    echo

    printf "  Register a local repository\n  This command adds the specified path to the configuration file.\n"
    echo

  else
    printf "rush add - Register a local repository\n"
    echo

  fi

  printf "Alias: a\n"
  echo

  printf "Usage:\n"
  printf "  rush add REPO PATH\n"
  printf "  rush add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  REPO"
    printf "    Repository name.\n"
    echo

    # :argument.usage
    echo "  PATH"
    printf "    Path to the repository.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  rush add default ~/rush-repos/default\n"
    echo

  fi
}

# :command.usage
rush_remove_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush remove\n"
    echo

    printf "  Unregister a local repository\n  This command removes the specified path to the configuration file.\n"
    echo

  else
    printf "rush remove - Unregister a local repository\n"
    echo

  fi

  printf "Alias: r\n"
  echo

  printf "Usage:\n"
  printf "  rush remove REPO [options]\n"
  printf "  rush remove --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --purge, -p"
    printf "    Also remove the local repository's directory.\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  REPO"
    printf "    Repository name.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  rush remove bobby\n"
    printf "  rush remove bobby --purge\n"
    echo

  fi
}

# :command.usage
rush_clone_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush clone\n"
    echo

    printf "  Clone a GitHub package repository\n  This command clones the repository and registers it in the\n  configuration file.\n"
    echo

  else
    printf "rush clone - Clone a GitHub package repository\n"
    echo

  fi

  printf "Usage:\n"
  printf "  rush clone GITHUB_USER [PATH] [options]\n"
  printf "  rush clone --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --ssh, -s"
    printf "    Clone using SSH instead of HTTPS.\n"
    echo

    # :flag.usage
    echo "  --default, -d"
    printf "    Set this as the default repository (same as '--name default').\n"
    echo

    # :flag.usage
    echo "  --name, -n NAME"
    printf "    Name to use in the config file.\n    Default: GitHub user\n"
    echo

    # :flag.usage
    echo "  --shallow, -w"
    printf "    Perform a shallow clone, instead of the default full clone.\n"
    echo

    # :flag.usage
    echo "  --ignore, -i"
    printf "    Ignore (do not clone) if a repository with this name exists.\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  GITHUB_USER"
    printf "    Github user.\n    This user is expected to have a repository named 'rush-repo'.\n    If you need to use a different name, use the 'user/repo' syntax.\n"
    echo

    # :argument.usage
    echo "  PATH"
    printf "    Local path to clone the repository to.\n    Default: ~/rush-repos/<github_user>/<github_repo>\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  rush clone bobby\n"
    printf "  rush clone bobby --default\n"
    printf "  rush clone bobby/bobs-repo ./repos/bobby --ssh\n"
    printf "  rush clone bobby --name sample --ignore\n"
    echo

  fi
}

# :command.usage
rush_pull_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush pull - Git pull one or all repositories\n"
    echo

  else
    printf "rush pull - Git pull one or all repositories\n"
    echo

  fi

  printf "Alias: p, download, update\n"
  echo

  printf "Usage:\n"
  printf "  rush pull [REPO]\n"
  printf "  rush pull --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  REPO"
    printf "    Repository name.\n"
    echo

  fi
}

# :command.usage
rush_push_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush push - Git push one or all repositories\n"
    echo

  else
    printf "rush push - Git push one or all repositories\n"
    echo

  fi

  printf "Alias: upload\n"
  echo

  printf "Usage:\n"
  printf "  rush push [REPO] [options]\n"
  printf "  rush push --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --all, -a"
    printf "    Push all repositories.\n"
    echo

    # :flag.usage
    echo "  --message, -m TEXT"
    printf "    Commit message.\n    Default: automatic commit\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  REPO"
    printf "    Repository name.\n    Default: default\n"
    echo

  fi
}

# :command.usage
rush_config_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush config - Show or edit the configuration file\n"
    echo

  else
    printf "rush config - Show or edit the configuration file\n"
    echo

  fi

  printf "Alias: c\n"
  echo

  printf "Usage:\n"
  printf "  rush config [options]\n"
  printf "  rush config --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --edit, -e"
    printf "    Open the configuration file for editing.\n"
    echo

  fi
}

# :command.usage
rush_default_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush default\n"
    echo

    printf "  Set a default repository\n  This command adds (or updates) a repository named 'default' to the\n  configuration file, and copies the path from the provided repo.\n"
    echo

  else
    printf "rush default - Set a default repository\n"
    echo

  fi

  printf "Usage:\n"
  printf "  rush default REPO\n"
  printf "  rush default --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  REPO"
    printf "    Repository name.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  rush default sample\n"
    echo

  fi
}

# :command.usage
rush_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush get\n"
    echo

    printf "  Install a package\n  This command runs the main script in the package directory.\n  \n  This is the default command, which means that running 'rush package' is\n  the same as running 'rush get package'.\n"
    echo

  else
    printf "rush get - Install a package\n"
    echo

  fi

  printf "Alias: g\n"
  echo

  printf "Usage:\n"
  printf "  rush get PACKAGE [options]\n"
  printf "  rush get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --clone, -c"
    printf "    Clone the repository if it is not found locally.\n    This flag will look for a GitHub user with the same name as the\n    repository, and attempt to clone their rush-repo repository.\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  rush ruby\n"
    printf "  rush get ruby\n"
    printf "  rush get centos:ruby\n"
    echo

  fi
}

# :command.usage
rush_undo_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush undo\n"
    echo

    printf "  Uninstall a package\n  This command runs the undo script in the package directory.\n"
    echo

  else
    printf "rush undo - Uninstall a package\n"
    echo

  fi

  printf "Alias: u\n"
  echo

  printf "Usage:\n"
  printf "  rush undo PACKAGE\n"
  printf "  rush undo --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  rush undo ruby\n"
    printf "  rush undo centos:ruby\n"
    echo

  fi
}

# :command.usage
rush_snatch_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush snatch\n"
    echo

    printf "  Install a package from a remote repo\n  This command is a shortcut to running clone followed by get.\n  It will clone the repository to a temporary directory and run the main\n  package script.\n"
    echo

  else
    printf "rush snatch - Install a package from a remote repo\n"
    echo

  fi

  printf "Usage:\n"
  printf "  rush snatch GITHUB_USER PACKAGE\n"
  printf "  rush snatch --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  GITHUB_USER"
    printf "    Github user.\n    This user is expected to have a repository named 'rush-repo'.\n    If you need to use a different name, use the 'user/repo' syntax.\n"
    echo

    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  rush snatch james python\n"
    printf "  rush snatch james/other-rush-repo python\n"
    echo

  fi
}

# :command.usage
rush_copy_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush copy - Copy a package between local repositories\n"
    echo

  else
    printf "rush copy - Copy a package between local repositories\n"
    echo

  fi

  printf "Usage:\n"
  printf "  rush copy SOURCE_PACKAGE [TARGET_PACKAGE] [options]\n"
  printf "  rush copy --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --force, -f"
    printf "    Copy the package even if it already exists in the target repository.\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  SOURCE_PACKAGE"
    printf "    Source package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo

    # :argument.usage
    echo "  TARGET_PACKAGE"
    printf "    Target package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n    If left empty, the package will be copied with the same name to the\n    default repository.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  rush copy james:python\n"
    printf "  rush copy james:python bobby\n"
    printf "  rush copy james:python bobby:python3 --force\n"
    echo

  fi
}

# :command.usage
rush_info_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush info\n"
    echo

    printf "  Show information about a package\n  This command shows the info file from the package directory.\n"
    echo

  else
    printf "rush info - Show information about a package\n"
    echo

  fi

  printf "Alias: i\n"
  echo

  printf "Usage:\n"
  printf "  rush info PACKAGE\n"
  printf "  rush info --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  rush info ruby\n"
    printf "  rush info centos:ruby\n"
    echo

  fi
}

# :command.usage
rush_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush list - Show packages in one or all repositories\n"
    echo

  else
    printf "rush list - Show packages in one or all repositories\n"
    echo

  fi

  printf "Alias: l\n"
  echo

  printf "Usage:\n"
  printf "  rush list [REPO_OR_PACKAGE] [options]\n"
  printf "  rush list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --simple, -s"
    printf "    Show only package names.\n"
    echo

    # :flag.usage
    echo "  --all, -a"
    printf "    Show nested packages as well.\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  REPO_OR_PACKAGE"
    printf "    Repository name or package name.\n    - Leave blank to show all packages in all repositories.\n    - Provide a repository name to show only packages in this repository.\n    - Provide a package name (may be in the form of 'repo:package') to\n      show nested packages.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  rush list\n"
    printf "  rush list personal:apps\n"
    printf "  rush list personal\n"
    printf "  rush list apps\n"
    printf "  rush list apps --simple --all\n"
    echo

  fi
}

# :command.usage
rush_search_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush search - Search in package names and info files\n"
    echo

  else
    printf "rush search - Search in package names and info files\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "Usage:\n"
  printf "  rush search TEXT\n"
  printf "  rush search --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  TEXT"
    printf "    Text to search for.\n"
    echo

  fi
}

# :command.usage
rush_edit_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush edit - Edit package files\n"
    echo

  else
    printf "rush edit - Edit package files\n"
    echo

  fi

  printf "Alias: e\n"
  echo

  printf "Usage:\n"
  printf "  rush edit PACKAGE [FILE]\n"
  printf "  rush edit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo

    # :argument.usage
    echo "  FILE"
    printf "    File to edit.\n    Default: main\n"
    echo

  fi
}

# :command.usage
rush_show_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush show - Show package files\n"
    echo

  else
    printf "rush show - Show package files\n"
    echo

  fi

  printf "Usage:\n"
  printf "  rush show PACKAGE [FILE]\n"
  printf "  rush show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo

    # :argument.usage
    echo "  FILE"
    printf "    File to show (show all if not specified).\n"
    echo

  fi
}

# :command.usage
rush_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush completions - Generate bash completions\n"
    echo

  else
    printf "rush completions - Generate bash completions\n"
    echo

  fi

  printf "Usage:\n"
  printf "  rush completions\n"
  printf "  rush completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/abort.sh
abort() {
  red "$1"
  exit 1
}

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/config.sh
config_init() {
  CONFIG_FILE=${CONFIG_FILE:=config.ini}
  [[ -f "$CONFIG_FILE" ]] || touch "$CONFIG_FILE"
}

config_get() {
  local key=$1
  local regex="^$key *= *(.+)$"
  local value=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      value="${BASH_REMATCH[1]}"
      break
    fi
  done < "$CONFIG_FILE"

  echo "$value"
}

config_set() {
  local key=$1
  shift
  local value="$*"

  config_init

  local regex="^($key) *= *.+$"
  local output=""
  local found_key=""
  local newline

  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line =~ $regex ]]; then
      found_key="${BASH_REMATCH[1]}"
      newline="$key = $value"
      output="$output$newline\n"
    elif [[ $line ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  if [[ -z $found_key ]]; then
    output="$output$key = $value\n"
  fi

  printf "%b\n" "$output" > "$CONFIG_FILE"
}

config_del() {
  local key=$1

  local regex="^($key) *="
  local output=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line ]] && [[ ! $line =~ $regex ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  printf "%b\n" "$output" > "$CONFIG_FILE"
}

config_show() {
  config_init
  cat "$CONFIG_FILE"
}

config_keys() {
  local regex="^([a-zA-Z0-9_\-\/\.]+) *="

  config_init

  local keys=()
  local key

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      key="${BASH_REMATCH[1]}"
      keys+=("$key")
    fi
  done < "$CONFIG_FILE"
  echo "${keys[@]}"
}

config_has_key() {
  [[ $(config_get "$1") ]]
}

# src/lib/is_busybox_grep.sh
is_busybox_grep() {
  grep --version 2>&1 /dev/null | grep -i busybox > /dev/null 2>&1
}

# src/lib/say.sh
say() {
  printf "%-20s | %s\n" "$(magenta "$1")" "$(bold "${*:2}")"
}

# src/lib/send_completions.sh
send_completions() {
  echo $'# rush completion                                          -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_rush_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $'  '
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_rush_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'completions\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'download\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'default\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'remove\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--help --purge -h -p")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'update\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'upload\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--all --help --message -a -h -m")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'config\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--edit --help -e -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'snatch\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'search\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'clone\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -A directory -W "$(_rush_completions_filter "--default --help --ignore --name --shallow --ssh -d -h -i -n -s -w")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'pull\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'push\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--all --help --message -a -h -m")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'undo\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "$(rush list -s -a) --help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'copy\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "$(rush list -s -a) --force --help -f -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'info\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "$(rush list -s -a) --help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'list\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--all --help --simple -a -h -s")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'edit\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "$(rush list -s -a) --help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'show\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "$(rush list -s -a) --help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'add\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -A directory -W "$(_rush_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'get\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "$(rush list -s -a) --clone --help -c -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'a\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -A directory -W "$(_rush_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'r\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--help --purge -h -p")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'p\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--edit --help -e -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'g\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "$(rush list -s -a) --clone --help -c -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'u\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "$(rush list -s -a) --help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'i\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "$(rush list -s -a) --help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'l\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--all --help --simple -a -h -s")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'e\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "$(rush list -s -a) --help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_rush_completions_filter "$(rush list -s -a) --help --version -h -v a add c clone completions config copy default download e edit g get i info l list p pull push r remove s search show snatch u undo update upload")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'complete -F _rush_completions rush'
  echo $''
  echo $'# ex: filetype=sh'
}

# src/lib/warn.sh
warn() {
  printf "%-20s | %s\n" "$(red "$1")" "$(red_bold "${*:2}")"
}

# :command.command_functions
# :command.function
rush_add_command() {
  # src/add_command.sh
  repo=${args[repo]}
  path=${args[path]}

  config_set "$repo" "$path"
  say "add" "$repo = $path"

}

# :command.function
rush_remove_command() {
  # src/remove_command.sh
  repo=${args[repo]}
  purge=${args[--purge]}

  say "remove" "$repo"

  if [[ $purge ]] ; then
    repo_path=$(config_get "$repo")
    if [[ -d $repo_path ]] ; then
      rm -rf "$repo_path"
      say "remove" "purged $repo_path"
    fi
  fi

  config_del "$repo"
}

# :command.function
rush_clone_command() {
  # src/clone_command.sh
  # Collect variables
  path=${args[path]}
  repo_id=${args[github_user]}
  use_ssh=${args[--ssh]}
  shallow=${args[--shallow]}
  ignore=${args[--ignore]}
  default_repo_name=${repo_id%%/*}
  default=${args[--default]}

  if [[ $default ]] ; then
    repo_name=default
  else
    repo_name=${args[--name]:-$default_repo_name}
  fi

  # Adjust repo_id - defaults to $user/rush-repo
  [[ $repo_id = */* ]] || repo_id="$repo_id/rush-repo"

  # Set clone URL - ssh or https?
  if [[ $use_ssh ]] ; then
    repo_url=git@github.com:$repo_id.git
  else
    repo_url=https://github.com/$repo_id.git
  fi

  # Set default path if not provided
  [[ $path ]] || path="$HOME/rush-repos/$repo_id"

  # Abort if target directory exists
  if [[ -d $path ]] ; then
    if [[ $ignore ]] ; then
      skip=1
    else
      abort "directory $path already exists."
    fi
  fi

  # Abort if a repository with this name already exists
  if config_has_key "$repo_name" ; then
    if [[ $ignore ]] ; then
      skip=1
    else
      abort "the repository is already registered:\n$repo_name = $(config_get "$repo_name")."
    fi
  fi

  if [[ $skip ]] ; then
    say "clone" "skipping $repo_name (exists)"

  else
    # Clone
    say "clone" "$repo_url"

    if [[ $shallow ]]; then
      git clone --depth 1 "$repo_url" "$path"
    else
      git clone "$repo_url" "$path"
    fi

    # Save config
    config_set "$repo_name" "$path"

  fi

}

# :command.function
rush_pull_command() {
  # src/pull_command.sh
  repo=${args[repo]}

  pull_repo() {
    local repo_path="$1"
    local repo="$2"

    if [[ -d "$repo_path/.git" ]]; then
      say "pull" "$repo"
      ( cd "$repo_path" && git pull )
    else
      say "pull" "skipping $repo (not a git repo)"
    fi
  }

  if [[ $repo ]]; then
    repo_path=$(config_get "$repo")
    [[ $repo_path ]] || abort "no such repo: $repo"
    pull_repo "$repo_path" "$repo"
  else
    for k in $(config_keys); do
      pull_repo "$(config_get "$k")" "$k"
    done
  fi

}

# :command.function
rush_push_command() {
  # src/push_command.sh
  set +e
  all=${args[--all]}
  repo=${args[repo]:-default}
  message=${args[--message]:-"automatic commit"}

  push_repo() {
    local repo_path="$1"
    local repo="$2"

    if [[ -d "$repo_path/.git" ]]; then
      say "push" "$repo"
      (
        set -e
        cd "$repo_path"
        git add . --all
        find . -type f \( -name main -o -name undo \) -exec git update-index --chmod +x {} \;
        git commit -am "$message"
        git push
      )
    else
      say "push" "skipping $repo (not a git repo)"
    fi
  }

  if [[ $all ]]; then
    for k in $(config_keys); do
      push_repo "$(config_get "$k")" "$k"
    done
  else
    repo_path=$(config_get "$repo")
    [[ $repo_path ]] || abort "no such repo: $repo"
    push_repo "$repo_path" "$repo"
  fi

}

# :command.function
rush_config_command() {
  # src/config_command.sh
  if [[ "${args[--edit]}" ]]; then
    editor="${EDITOR:-vi}"
    "$editor" "$CONFIG_FILE"
  else
    cyan "# $CONFIG_FILE"
    config_show
  fi

}

# :command.function
rush_default_command() {
  # src/default_command.sh
  # Collect variables
  repo=${args[repo]}
  repo_path=$(config_get "$repo")

  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"

  config_set "default" "$repo_path"
  config_del "$repo"
  say "default" "$repo ($repo_path)"
}

# :command.function
rush_get_command() {
  # src/get_command.sh
  # Collect variables
  package=${args[package]}
  repo="default"
  clone=${args[--clone]}

  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi

  if ! config_has_key "$repo" && [[ $clone ]] && [[ $repo != 'default' ]]; then
    say "get" "repo $repo does not exist, attempting clone"
    rush clone "$repo"
  fi

  repo_path=$(config_get "$repo")
  package_path=$repo_path/$package
  script=$package_path/main

  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo:$package"
  [[ -f $script ]] || abort "script not found: $script"

  # Run the script (make it executable if it isnt first)
  export REPO="$repo"
  export REPO_PATH="$repo_path"
  [[ -z "$USER_CWD" ]] && export USER_CWD="$PWD"

  if [[ $repo == "default" ]] ; then
    package_name="$package"
  else
    package_name="$repo:$package"
  fi

  say "get" "$package_name"
  [[ -x "$script" ]] || chmod u+x "$script"
  cd "$package_path"

  finish() {
    exitcode="$?"
    [[ $exitcode == 0 ]] || warn "get" "$package_name exited with error ($exitcode)"
  }

  trap finish EXIT

  ./main

}

# :command.function
rush_undo_command() {
  # src/undo_command.sh
  # Collect variables
  package=${args[package]}
  repo="default"

  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi

  repo_path=$(config_get "$repo")
  package_path=$repo_path/$package
  script=$package_path/undo

  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo:$package"
  [[ -f $script ]] || abort "script not found: $script"

  # Run the script (make it executable if it isnt first)
  export REPO="$repo"
  export REPO_PATH="$repo_path"
  [[ -z "$USER_CWD" ]] && export USER_CWD="$PWD"

  if [[ $repo == "default" ]] ; then
    package_name="$package"
  else
    package_name="$repo:$package"
  fi

  say "undo" "$package_name"
  [[ -x "$script" ]] || chmod u+x "$script"
  cd "$package_path"

  finish() {
    exitcode="$?"
    [[ $exitcode == 0 ]] || warn "undo" "$package_name exited with error ($exitcode)"
  }

  trap finish EXIT

  ./undo

}

# :command.function
rush_snatch_command() {
  # src/snatch_command.sh
  # Collect variables
  repo_id=${args[github_user]}
  package=${args[package]}
  path="$HOME/rush-repos/snatched"

  cleanup() {
    rush remove snatched --purge
  }

  say "snatch" "$repo_id $package"

  trap cleanup EXIT ERR INT TERM

  rush clone "$repo_id" "$path" --name snatched
  rush get "snatched:$package"

}

# :command.function
rush_copy_command() {
  # src/copy_command.sh
  source_package=${args[source_package]}
  target_package=${args[target_package]}
  force=${args[--force]}
  source_repo=default
  target_repo=default

  if [[ $source_package =~ (.*):(.*) ]]; then
    source_repo=${BASH_REMATCH[1]}
    source_package=${BASH_REMATCH[2]}
  fi

  if [[ -z "$target_package" ]]; then
    target_package="$source_package"
  elif [[ $target_package =~ (.*):(.*) ]]; then
    target_repo=${BASH_REMATCH[1]}
    target_package=${BASH_REMATCH[2]}
  fi

  source_repo_path=$(config_get "$source_repo")
  target_repo_path=$(config_get "$target_repo")
  source_package_path="$source_repo_path/$source_package"
  target_package_path="$target_repo_path/$target_package"

  if [[ $source_repo == "default" ]]; then
    source_display_name="$source_package"
  else
    source_display_name="$source_repo:$source_package"
  fi

  if [[ $target_repo == "default" ]]; then
    target_display_name="$target_package"
  else
    target_display_name="$target_repo:$target_package"
  fi

  [[ $source_repo_path ]] || abort "source repo not found: $source_repo"
  [[ $target_repo_path ]] || abort "target repo not found: $target_repo"
  [[ -d $source_package_path ]] || abort "source package not found: $source_repo:$source_package"
  if [[ -d $target_package_path ]]; then
    if [[ $force ]]; then
      rm -rf "$target_package_path"
    else
      abort "target package already exists: $target_repo:$target_package\nrun again with --force to copy anyway"
    fi
  fi

  say "copy" "$source_display_name to $target_display_name"
  mkdir -p "$(dirname "$target_package_path")"
  cp -R "$source_package_path" "$target_package_path"

}

# :command.function
rush_info_command() {
  # src/info_command.sh
  # Collect variables
  package=${args[package]}
  repo="default"

  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi

  repo_path=$(config_get "$repo")
  package_path="$repo_path/$package"
  infofile="$package_path/info"

  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo:$package"
  [[ -f $infofile ]] || abort "infofile not found: $infofile"

  cat "$infofile"

}

# :command.function
rush_list_command() {
  # src/list_command.sh
  list_display_item() {
    package="$1"
    infofile="$2"
    repo="$3"
    simple=${args[--simple]}
    width=$(( ${COLUMNS:-80} + 9))

    [[ "$repo" != "default" ]] && package="$repo:$package"
    if [[ $simple ]]; then
      printf "%s\n" "$package"
    else
      info=$(head -1 "$infofile" 2> /dev/null)
      padded_package=$(printf "%-20s" "$package")
      message="$(green "$padded_package")  $info"
      printf "%.${width}s\n" "$message"
    fi
  }

  list_show_repo() {
    local repo_or_package="$1"
    local search="${args[--search]}"
    local simple=${args[--simple]}
    local all=${args[--all]}
    local repo="$repo_or_package"
    local package glob repo_path infofile regex package_name

    if [[ $all ]]; then
      shopt -s globstar
    fi

    if [[ $repo_or_package =~ (.*):(.*) ]]; then
      repo=${BASH_REMATCH[1]}
      package=${BASH_REMATCH[2]}
    fi

    repo_path=$(config_get "$repo")

    if [[ ! $repo_path ]]; then
      package="$repo"
      repo="default"
      repo_path=$(config_get "$repo")
    fi

    if [[ $package ]]; then
      glob=( "$repo_path"/"$package"/**/info )
    else
      glob=( "$repo_path"/**/info )
    fi

    if [[ ${glob[0]} =~ .*\*.* ]]; then
      infofile="$repo_path/$package/info"
      if [[ -f "$infofile" ]]; then
        list_display_item "$package" "$infofile" "$repo"
      elif [[ ! $simple ]]; then
        red "nothing in $repo repo"
      fi

    else
      for infofile in "${glob[@]}"; do
        if [[ $search ]]; then
          regex="$repo_path/(.*${search}.*)/info"
        else
          regex="$repo_path/(.*)/info"
        fi

        if [[ $infofile =~ $regex ]]; then
          package_name="${BASH_REMATCH[1]}"
          list_display_item "$package_name" "$infofile" "$repo"
        fi
      done
    fi
  }

  repo_or_package=${args[repo_or_package]}

  if [[ $repo_or_package ]]; then
    list_show_repo "$repo_or_package"
  else
    for k in $(config_keys); do
      list_show_repo "$k"
    done
  fi

}

# :command.function
rush_search_command() {
  # src/search_command.sh
  search_repo() {
    repo="$1"
    text="$2"
    set +e

    repo_path=$(config_get "$repo")

    # Add "repo:" to the result unless it is the default
    prefix=''
    [[ "$repo" != "default" ]] && prefix="$repo:"

    # Search directories matching search text
    blue "Matching packages:\n"
    find "$repo_path" -type d -not -path '*/\.*' | grep --color=always "$text" | \
      sed "s#${repo_path}/#${prefix}#g" | sed 's#/info##'

    # Search info files matching search text
    blue "\nMatching info files:\n"
    grep --color=always --initial-tab --recursive --ignore-case --include "info" \
      "$text" "$repo_path" | \
      sort | \
      sed "s#${repo_path}/#${prefix}#g" | sed 's#/info##'

    echo
  }

  if is_busybox_grep; then
    abort "cannot run with BusyBox grep.\nplease install GNU grep:\napk add --no-cache grep"
  fi

  text=${args[text]}

  for k in $(config_keys); do
    search_repo "$k" "$text"
  done

}

# :command.function
rush_edit_command() {
  # src/edit_command.sh
  # Collect variables
  package=${args[package]}
  file=${args[file]:-main}
  repo="default"
  edit=${EDITOR:-vi}

  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi

  repo_path=$(config_get "$repo")
  package_path="$repo_path/$package"
  file_path="$package_path/$file"

  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo:$package"
  [[ -f $file_path ]] || abort "file not found: $file_path"

  # Edit the file
  "$edit" "$file_path"

}

# :command.function
rush_show_command() {
  # src/show_command.sh
  # Collect variables
  package=${args[package]}
  file=${args[file]}
  repo="default"

  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi

  repo_path=$(config_get "$repo")
  package_path="$repo_path/$package"
  file_path="$package_path/$file"

  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo:$package"

  # Show the package data
  if [[ $file ]]; then
    [[ -f $file_path ]] || abort "file not found: $file_path"
    cat "$file_path"
  else
    shopt -s dotglob
    for f in "$package_path"/*; do
      if [[ -f "$f" ]]; then
        green "$(basename "$f")"
        cat "$f"
        echo
        echo
      fi
    done
    shopt -u dotglob
  fi

}

# :command.function
rush_completions_command() {
  # src/completions_command.sh
  send_completions
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    rush_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  add | a )
    action="add"
    shift
    rush_add_parse_requirements "$@"
    shift $#
    ;;

  remove | r )
    action="remove"
    shift
    rush_remove_parse_requirements "$@"
    shift $#
    ;;

  clone )
    action="clone"
    shift
    rush_clone_parse_requirements "$@"
    shift $#
    ;;

  pull | p | download | update )
    action="pull"
    shift
    rush_pull_parse_requirements "$@"
    shift $#
    ;;

  push | upload )
    action="push"
    shift
    rush_push_parse_requirements "$@"
    shift $#
    ;;

  config | c )
    action="config"
    shift
    rush_config_parse_requirements "$@"
    shift $#
    ;;

  default )
    action="default"
    shift
    rush_default_parse_requirements "$@"
    shift $#
    ;;

  get | g )
    action="get"
    shift
    rush_get_parse_requirements "$@"
    shift $#
    ;;

  undo | u )
    action="undo"
    shift
    rush_undo_parse_requirements "$@"
    shift $#
    ;;

  snatch )
    action="snatch"
    shift
    rush_snatch_parse_requirements "$@"
    shift $#
    ;;

  copy )
    action="copy"
    shift
    rush_copy_parse_requirements "$@"
    shift $#
    ;;

  info | i )
    action="info"
    shift
    rush_info_parse_requirements "$@"
    shift $#
    ;;

  list | l )
    action="list"
    shift
    rush_list_parse_requirements "$@"
    shift $#
    ;;

  search | s )
    action="search"
    shift
    rush_search_parse_requirements "$@"
    shift $#
    ;;

  edit | e )
    action="edit"
    shift
    rush_edit_parse_requirements "$@"
    shift $#
    ;;

  show )
    action="show"
    shift
    rush_show_parse_requirements "$@"
    shift $#
    ;;

  completions )
    action="completions"
    shift
    rush_completions_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    rush_usage
    exit 1
    ;;

  * )
    action="get"
    rush_get_parse_requirements "$@"
    shift $#
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
rush_add_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_add_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[repo]+x} ]]; then

        args[repo]=$1
        shift
      elif [[ -z ${args[path]+x} ]]; then

        args[path]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[repo]+x} ]]; then
    printf "missing required argument: REPO\nusage: rush add REPO PATH\n"
    exit 1
  fi
  if [[ -z ${args[path]+x} ]]; then
    printf "missing required argument: PATH\nusage: rush add REPO PATH\n"
    exit 1
  fi

}

# :command.parse_requirements
rush_remove_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_remove_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="remove"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --purge | -p )

      # :flag.case_no_arg
      args[--purge]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[repo]+x} ]]; then

        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[repo]+x} ]]; then
    printf "missing required argument: REPO\nusage: rush remove REPO [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
rush_clone_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_clone_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="clone"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --ssh | -s )

      # :flag.case_no_arg
      args[--ssh]=1
      shift
      ;;

    # :flag.case
    --default | -d )

      # :flag.case_no_arg
      args[--default]=1
      shift
      ;;

    # :flag.case
    --name | -n )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--name]="$2"
        shift
        shift
      else
        printf "%s\n" "--name requires an argument: --name, -n NAME"
        exit 1
      fi
      ;;

    # :flag.case
    --shallow | -w )

      # :flag.case_no_arg
      args[--shallow]=1
      shift
      ;;

    # :flag.case
    --ignore | -i )

      # :flag.case_no_arg
      args[--ignore]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[github_user]+x} ]]; then

        args[github_user]=$1
        shift
      elif [[ -z ${args[path]+x} ]]; then

        args[path]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[github_user]+x} ]]; then
    printf "missing required argument: GITHUB_USER\nusage: rush clone GITHUB_USER [PATH] [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
rush_pull_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_pull_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="pull"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[repo]+x} ]]; then

        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

}

# :command.parse_requirements
rush_push_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_push_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="push"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --all | -a )

      # :flag.case_no_arg
      args[--all]=1
      shift
      ;;

    # :flag.case
    --message | -m )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--message]="$2"
        shift
        shift
      else
        printf "%s\n" "--message requires an argument: --message, -m TEXT"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[repo]+x} ]]; then

        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

}

# :command.parse_requirements
rush_config_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_config_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="config"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --edit | -e )

      # :flag.case_no_arg
      args[--edit]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
rush_default_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_default_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="default"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[repo]+x} ]]; then

        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[repo]+x} ]]; then
    printf "missing required argument: REPO\nusage: rush default REPO\n"
    exit 1
  fi

}

# :command.parse_requirements
rush_get_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_get_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --clone | -c )

      # :flag.case_no_arg
      args[--clone]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[package]+x} ]]; then

        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[package]+x} ]]; then
    printf "missing required argument: PACKAGE\nusage: rush get PACKAGE [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
rush_undo_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_undo_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="undo"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[package]+x} ]]; then

        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[package]+x} ]]; then
    printf "missing required argument: PACKAGE\nusage: rush undo PACKAGE\n"
    exit 1
  fi

}

# :command.parse_requirements
rush_snatch_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_snatch_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="snatch"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[github_user]+x} ]]; then

        args[github_user]=$1
        shift
      elif [[ -z ${args[package]+x} ]]; then

        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[github_user]+x} ]]; then
    printf "missing required argument: GITHUB_USER\nusage: rush snatch GITHUB_USER PACKAGE\n"
    exit 1
  fi
  if [[ -z ${args[package]+x} ]]; then
    printf "missing required argument: PACKAGE\nusage: rush snatch GITHUB_USER PACKAGE\n"
    exit 1
  fi

}

# :command.parse_requirements
rush_copy_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_copy_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="copy"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --force | -f )

      # :flag.case_no_arg
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[source_package]+x} ]]; then

        args[source_package]=$1
        shift
      elif [[ -z ${args[target_package]+x} ]]; then

        args[target_package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[source_package]+x} ]]; then
    printf "missing required argument: SOURCE_PACKAGE\nusage: rush copy SOURCE_PACKAGE [TARGET_PACKAGE] [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
rush_info_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_info_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="info"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[package]+x} ]]; then

        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[package]+x} ]]; then
    printf "missing required argument: PACKAGE\nusage: rush info PACKAGE\n"
    exit 1
  fi

}

# :command.parse_requirements
rush_list_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_list_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --simple | -s )

      # :flag.case_no_arg
      args[--simple]=1
      shift
      ;;

    # :flag.case
    --all | -a )

      # :flag.case_no_arg
      args[--all]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[repo_or_package]+x} ]]; then

        args[repo_or_package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

}

# :command.parse_requirements
rush_search_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_search_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="search"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[text]+x} ]]; then

        args[text]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[text]+x} ]]; then
    printf "missing required argument: TEXT\nusage: rush search TEXT\n"
    exit 1
  fi

}

# :command.parse_requirements
rush_edit_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_edit_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="edit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[package]+x} ]]; then

        args[package]=$1
        shift
      elif [[ -z ${args[file]+x} ]]; then

        args[file]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[package]+x} ]]; then
    printf "missing required argument: PACKAGE\nusage: rush edit PACKAGE [FILE]\n"
    exit 1
  fi

}

# :command.parse_requirements
rush_show_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_show_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[package]+x} ]]; then

        args[package]=$1
        shift
      elif [[ -z ${args[file]+x} ]]; then

        args[file]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[package]+x} ]]; then
    printf "missing required argument: PACKAGE\nusage: rush show PACKAGE [FILE]\n"
    exit 1
  fi

}

# :command.parse_requirements
rush_completions_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    rush_completions_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.7.4"
  long_usage=''
  set -e

  # src/initialize.sh
  CONFIG_FILE=${RUSH_CONFIG:-~/rush.ini}
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "add" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_add_usage
    else
      rush_add_command
    fi

  elif [[ $action == "remove" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_remove_usage
    else
      rush_remove_command
    fi

  elif [[ $action == "clone" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_clone_usage
    else
      rush_clone_command
    fi

  elif [[ $action == "pull" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_pull_usage
    else
      rush_pull_command
    fi

  elif [[ $action == "push" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_push_usage
    else
      rush_push_command
    fi

  elif [[ $action == "config" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_config_usage
    else
      rush_config_command
    fi

  elif [[ $action == "default" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_default_usage
    else
      rush_default_command
    fi

  elif [[ $action == "get" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_get_usage
    else
      rush_get_command
    fi

  elif [[ $action == "undo" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_undo_usage
    else
      rush_undo_command
    fi

  elif [[ $action == "snatch" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_snatch_usage
    else
      rush_snatch_command
    fi

  elif [[ $action == "copy" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_copy_usage
    else
      rush_copy_command
    fi

  elif [[ $action == "info" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_info_usage
    else
      rush_info_command
    fi

  elif [[ $action == "list" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_list_usage
    else
      rush_list_command
    fi

  elif [[ $action == "search" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_search_usage
    else
      rush_search_command
    fi

  elif [[ $action == "edit" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_edit_usage
    else
      rush_edit_command
    fi

  elif [[ $action == "show" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_show_usage
    else
      rush_show_command
    fi

  elif [[ $action == "completions" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      rush_completions_usage
    else
      rush_completions_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
